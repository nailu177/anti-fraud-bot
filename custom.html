<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‡ªå®šä¹‰æ¨¡å— - Anti-Fraud é˜²è¯ˆéª—bot</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-color: #f7f7f8;
            --card-bg: rgba(255, 255, 255, 0.8);
            --text-color: #1f2a44;
            --code-bg: #f1f5f9;
            --code-text: #1f2a44;
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #1a1a1c;
                --card-bg: rgba(30, 30, 30, 0.8);
                --text-color: #ffffff;
                --code-bg: #2d2d2d;
                --code-text: #e5e7eb;
            }
            .copy-btn {
                background: #4b5563;
                color: #ffffff;
            }
            .copy-btn:hover {
                background: #6b7280;
            }
        }
        body {
            background: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }
        .glass {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        .title-enter {
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .dropdown-menu {
            display: none;
        }
        .dropdown-menu.show {
            display: block;
        }
        .dropdown-menu a:hover {
            background: #e5e7eb;
        }
        .content-container {
            max-height: 70vh;
            overflow-y: auto;
            padding: 1rem;
            border-radius: 8px;
        }
        .code-block {
            position: relative;
            background: var(--code-bg);
            color: var(--code-text);
            padding: 1rem;
            border-radius: 8px;
            font-family: monospace;
            margin-bottom: 1rem;
            max-height: 300px;
            overflow-y: auto;
        }
        .code-block code {
            white-space: pre-wrap;
            word-wrap: break-word;
            display: block;
        }
        .copy-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: #e5e7eb;
            color: #1f2a44;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: background 0.2s;
        }
        .copy-btn:hover {
            background: #d1d5db;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4">
    <!-- å¯¼èˆª -->
    <nav class="w-full max-w-4xl flex justify-between items-center mb-8">
        <a href="index.html" class="text-lg font-semibold text-[var(--text-color)]">Anti-Fraud ğŸ›¡</a>
        <div class="dropdown relative">
            <button id="menuButton" class="text-[var(--text-color)] focus:outline-none">â˜°</button>
            <div id="dropdownMenu" class="dropdown-menu absolute right-0 mt-2 w-48 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-lg">
                <a href="index.html" class="block px-4 py-2 text-sm text-[var(--text-color)] hover:bg-gray-100 dark:hover:bg-gray-700">é¦–é¡µ</a>
                <a href="detect.html" class="block px-4 py-2 text-sm text-[var(--text-color)] hover:bg-gray-100 dark:hover:bg-gray-700">æ£€æµ‹</a>
                <a href="learn.html" class="block px-4 py-2 text-sm text-[var(--text-color)] hover:bg-gray-100 dark:hover:bg-gray-700">äº†è§£æ›´å¤š</a>
            </div>
        </div>
    </nav>
    <!-- å†…å®¹ -->
    <div class="glass p-6 rounded-3xl shadow-lg w-full max-w-4xl flex-1 flex flex-col">
        <div class="text-center mb-6 title-enter">
            <h1 class="text-3xl font-bold text-[var(--text-color)]">
                Bot Only For You
            </h1>
            <p class="text-sm text-[var(--text-color)] opacity-80 mt-1">
                ä½¿ç”¨æˆ‘ä»¬çš„å…¬å¼€ä»£ç ï¼Œè®­ç»ƒä½ è‡ªå·±çš„ä¸“å±é˜²è¯ˆéª—æ¨¡å‹ï¼Œå®šåˆ¶åŒ–ä¿æŠ¤ä½ çš„è´¢äº§å®‰å…¨ã€‚
            </p>
        </div>
        <div class="content-container">
            <!-- è‡ªå®šä¹‰é˜²è¯ˆéª—æ¨¡å‹ä½¿ç”¨è¯´æ˜ -->
            <div class="mb-6">
                <h2 class="text-xl font-semibold text-[var(--text-color)] mb-2">è‡ªå®šä¹‰ä¸“é—¨è¯ˆéª—ç±»å‹çš„Anti-Fraud Botæ•™ç¨‹</h2>
                <p class="text-sm text-[var(--text-color)] opacity-80 mb-4">
                    ä»¥ä¸‹ä»£ç æä¾›äº†ä»æ•°æ®å‡†å¤‡åˆ°æ¨¡å‹è®­ç»ƒã€è¯­éŸ³è½¬å½•å’Œå®æ—¶è¯ˆéª—æ£€æµ‹çš„å®Œæ•´æµç¨‹ã€‚ä½ å¯ä»¥æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤è‡ªå®šä¹‰é˜²è¯ˆéª—æ¨¡å‹ï¼š<br>
                    1. <strong>å‡†å¤‡æ•°æ®</strong>ï¼šæ”¶é›†åŒ…å«ä½ æƒ³è‡ªå®šä¹‰ç±»å‹çš„è¯ˆéª—å’Œæ­£å¸¸æ–‡æœ¬çš„æ•°æ®é›†ï¼ˆCSV æ ¼å¼ï¼‰ï¼Œç¡®ä¿æœ‰ `text` å’Œ `label` åˆ—ï¼ˆ0 è¡¨ç¤ºæ­£å¸¸ï¼Œ1 è¡¨ç¤ºè¯ˆéª—ï¼‰ã€‚<br>
                    2. <strong>è®­ç»ƒ BERT æ¨¡å‹</strong>ï¼šä½¿ç”¨æ•°æ®é›†éƒ¨åˆ†å’Œè®­ç»ƒå‡½æ•°éƒ¨åˆ†ï¼Œè®­ç»ƒä¸€ä¸ª BERT åˆ†ç±»å™¨ï¼Œä¿å­˜æ¨¡å‹æƒé‡ã€‚<br>
                    3. <strong>å¤„ç†è¯­éŸ³æ•°æ®</strong>ï¼šä½¿ç”¨ Whisper æ¨¡å‹éƒ¨åˆ†å°†è¯­éŸ³è½¬å½•ä¸ºæ–‡æœ¬ã€‚<br>
                    4. <strong>å®æ—¶æ£€æµ‹</strong>ï¼šä½¿ç”¨ Fraud Detection Monitor éƒ¨åˆ†ï¼ŒåŠ è½½è®­ç»ƒå¥½çš„æ¨¡å‹ï¼Œæ£€æµ‹è¾“å…¥æ–‡æœ¬çš„è¯ˆéª—é£é™©ã€‚<br>
                    5. <strong>éƒ¨ç½²</strong>ï¼šå°†æ¨¡å‹é›†æˆåˆ°åç«¯æœåŠ¡ï¼Œé€šè¿‡ API æä¾›å®æ—¶æ£€æµ‹åŠŸèƒ½ã€‚<br>
                    <strong>æ³¨æ„</strong>ï¼šè¯·æ£€æŸ¥ä½ çš„è™šæ‹Ÿç¯å¢ƒï¼Œå¹¶ç¡®ä¿æœ¬åœ°æœ‰ `bert-base-chinese` æ¨¡å‹æƒé‡å’Œ `ffmpeg`ã€‚
                </p>
            </div>
            <!-- æ•°æ®é›†éƒ¨åˆ† -->
            <div class="mb-6">
                <h2 class="text-xl font-semibold text-[var(--text-color)] mb-2">å‡†å¤‡æ•°æ®é›†</h2>
                <p class="text-sm text-[var(--text-color)] opacity-80 mb-4">
                    <strong>åŠŸèƒ½</strong>ï¼šåŠ è½½é’ˆå¯¹æŸå‡ ç±»è¯ˆéª—çš„è®­ç»ƒå’Œæµ‹è¯•æ•°æ®é›†ï¼Œå¹¶æ‹†åˆ†ä¸ºè®­ç»ƒé›†å’ŒéªŒè¯é›†ï¼Œç”¨äºåç»­ BERT æ¨¡å‹è®­ç»ƒã€‚<br>
                    <strong>ç”¨æ³•</strong>ï¼šç¡®ä¿æ•°æ®é›†ä¸º CSV æ ¼å¼ï¼ŒåŒ…å« `text`å’Œ `label`ã€‚ä»£ç ä¼šè‡ªåŠ¨æ‹†åˆ†æ•°æ®ã€‚<br>
                </p>
                <div class="code-block" id="dataset-code">
                    <button class="copy-btn" onclick="copyCode('dataset-code')">å¤åˆ¶</button>
                    <code>
import pandas as pd
from sklearn.model_selection import train_test_split

# åŠ è½½æ•°æ®
train_df = pd.read_csv(r'D:\anti-fraud\Bert\fraud_train.csv')
test_df = pd.read_csv(r'D:\anti-fraud\Bert\fraud_test.csv')

# ç¡®ä¿åˆ—åæ­£ç¡®ï¼Œå¦‚éœ€ä¿®æ”¹è¯·æ ¹æ®å®é™…åˆ—åè°ƒæ•´
train_texts, val_texts, train_labels, val_labels = train_test_split(
    train_df['text'].tolist(), train_df['label'].tolist(), test_size=0.1, random_state=42
)

test_texts = test_df['text'].tolist()
test_labels = test_df['label'].tolist()
                    </code>
                </div>
            </div>
            <!-- BERT æ¨¡å‹éƒ¨åˆ† -->
            <div class="mb-6">
                <h2 class="text-xl font-semibold text-[var(--text-color)] mb-2">ä½¿ç”¨BERT æ¨¡å‹</h2>
                <p class="text-sm text-[var(--text-color)] opacity-80 mb-4">
                    <strong>åŠŸèƒ½</strong>ï¼šBERT æ¨¡å‹å’Œæ•°æ®é›†ç±»ï¼Œç”¨äºæ–‡æœ¬åˆ†ç±»ã€‚<br>
                    <strong>ç”¨æ³•</strong>ï¼š`BERTDataset` å°†æ–‡æœ¬è½¬ä¸º BERT è¾“å…¥æ ¼å¼ï¼Œ`BertClassifier` ä½¿ç”¨ BERT è¿›è¡Œåˆ†ç±»ï¼Œè¾“å‡ºè¯ˆéª—æ¦‚ç‡ã€‚<br>
                    <strong>éœ€è¦è¡¥å……</strong>ï¼š<br>
                    - ä¿®æ”¹ `model_path`ï¼ˆå¦‚ `D:\anti-fraud\bert-base-chinese`ï¼‰ï¼ŒæŒ‡å‘ä½ æœ¬åœ°ä¸‹è½½çš„ `bert-base-chinese` æ¨¡å‹è·¯å¾„ã€‚<br>
                    - æ ¹æ®éœ€è¦è°ƒæ•´ `max_length`ï¼ˆé»˜è®¤ 128ï¼‰å’Œ `dropout`ï¼ˆé»˜è®¤ 0.5ï¼‰ã€‚
                </p>
                <div class="code-block" id="bert-code">
                    <button class="copy-btn" onclick="copyCode('bert-code')">å¤åˆ¶</button>
                    <code>
import torch
from torch import nn
from torch.utils.data import Dataset
from transformers import BertTokenizer, BertModel

# æœ¬åœ°æ–‡ä»¶å¤¹è·¯å¾„
model_path = r"D:\anti-fraud\bert-base-chinese"

# åŠ è½½æœ¬åœ°æ¨¡å‹å’Œtokenizer
tokenizer = BertTokenizer.from_pretrained(model_path)
model = BertModel.from_pretrained(model_path)

# è‡ªå®šä¹‰ Dataset
class BERTDataset(Dataset):
    def __init__(self, texts, labels):
        self.encodings = tokenizer(texts, truncation=True, padding=True, max_length=128, return_tensors="pt")
        self.labels = torch.tensor(labels)

    def __getitem__(self, idx):
        return {key: val[idx] for key, val in self.encodings.items()}, self.labels[idx]

    def __len__(self):
        return len(self.labels)

# æ¨¡å‹å®šä¹‰
class BertClassifier(nn.Module):
    def __init__(self, dropout=0.5, num_labels=2, model_path=None):
        super(BertClassifier, self).__init__()
        self.bert = BertModel.from_pretrained(model_path)
        self.dropout = nn.Dropout(dropout)
        self.classifier = nn.Linear(768, num_labels)

    def forward(self, input_id, mask):
        _, pooled_output = self.bert(input_ids=input_id, attention_mask=mask, return_dict=False)
        out = self.dropout(pooled_output)
        return self.classifier(out)
                    </code>
                </div>
            </div>
            <!-- Whisper æ¨¡å‹éƒ¨åˆ† -->
            <div class="mb-6">
                <h2 class="text-xl font-semibold text-[var(--text-color)] mb-2">ä½¿ç”¨Whisper æ¨¡å‹éƒ¨åˆ†</h2>
                <p class="text-sm text-[var(--text-color)] opacity-80 mb-4">
                    <strong>åŠŸèƒ½</strong>ï¼šä½¿ç”¨ Whisper æ¨¡å‹å°†è¯­éŸ³æ–‡ä»¶è½¬å½•ä¸ºæ–‡æœ¬ï¼Œæ”¯æŒåç»­è¯ˆéª—æ£€æµ‹ã€‚<br>
                    <strong>ç”¨æ³•</strong>ï¼š`transcribe_audio` å‡½æ•°æ¥æ”¶éŸ³é¢‘æ–‡ä»¶è·¯å¾„ï¼Œè¿”å›è½¬å½•åçš„æ–‡æœ¬ã€‚æ”¯æŒä¸åŒå‹å·ï¼ˆå¦‚ `base`ã€`small`ï¼‰ã€‚<br>
                </p>
                <div class="code-block" id="whisper-code">
                    <button class="copy-btn" onclick="copyCode('whisper-code')">å¤åˆ¶</button>
                    <code>
import whisper
import os

# è®¾ç½® ffmpeg è·¯å¾„ï¼ˆç¡®ä¿ Whisper èƒ½æ‰¾åˆ° ffmpegï¼‰
os.environ["PATH"] += os.pathsep + r"C:\ProgramData\chocolatey\bin"

# åŠ è½½ Whisper æ¨¡å‹å¹¶è½¬å½•
model = whisper.load_model("base")
result = model.transcribe(r"D:\anti-fraud\whisper\test_1.m4a")
print(result['text'])

def transcribe_audio(audio_path, model_name="base"):
    """
    Transcribe audio file to text using Whisper
    Args:
        audio_path: Path to the audio file
        model_name: Whisper model size (e.g., 'base', 'small')
    Returns:
        str: Transcribed text
    """
    try:
        model = whisper.load_model(model_name)
        result = model.transcribe(audio_path)
        return result['text']
    except Exception as e:
        print(f"Error transcribing audio {audio_path}: {e}")
        return None
                    </code>
                </div>
            </div>
            <!-- è®­ç»ƒå‡½æ•°éƒ¨åˆ† -->
            <div class="mb-6">
                <h2 class="text-xl font-semibold text-[var(--text-color)] mb-2">è°ƒç”¨è®­ç»ƒå‡½æ•°</h2>
                <p class="text-sm text-[var(--text-color)] opacity-80 mb-4">
                    <strong>åŠŸèƒ½</strong>ï¼šæä¾› BERT æ¨¡å‹çš„è®­ç»ƒã€éªŒè¯å’Œæµ‹è¯•å‡½æ•°ï¼Œç”¨äºè®­ç»ƒé˜²è¯ˆéª—åˆ†ç±»å™¨ã€‚<br>
                    <strong>ç”¨æ³•</strong>ï¼š<br>
                    - `train`ï¼šè®­ç»ƒæ¨¡å‹ï¼Œä¿å­˜æƒé‡åˆ° `bert_classifier.pt`ã€‚<br>
                    - `evaluate`ï¼šè¯„ä¼°æ¨¡å‹åœ¨éªŒè¯é›†ä¸Šçš„è¡¨ç°ï¼Œè¿”å›æŸå¤±å’Œå‡†ç¡®ç‡ã€‚<br>
                    - `test`ï¼šæµ‹è¯•æ¨¡å‹åœ¨æµ‹è¯•é›†ä¸Šçš„è¡¨ç°ï¼Œè¾“å‡ºåˆ†ç±»æŠ¥å‘Šã€‚<br>
                </p>
                <div class="code-block" id="train-code">
                    <button class="copy-btn" onclick="copyCode('train-code')">å¤åˆ¶</button>
                    <code>
import torch
from torch.utils.data import DataLoader
from torch.optim import Adam
from torch import nn
from sklearn.metrics import classification_report
from tqdm import tqdm

def train(model, train_data, val_data, learning_rate=1e-5, epochs=5, batch_size=4):
    train_loader = DataLoader(train_data, batch_size=batch_size, shuffle=True)
    val_loader = DataLoader(val_data, batch_size=batch_size)

    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)

    criterion = nn.CrossEntropyLoss()
    optimizer = Adam(model.parameters(), lr=learning_rate)

    for epoch in range(epochs):
        model.train()
        total_loss, total_acc = 0, 0

        for batch in tqdm(train_loader, desc=f"Training Epoch {epoch+1}"):
            inputs, labels = batch
            labels = labels.to(device)
            mask = inputs['attention_mask'].to(device)
            input_ids = inputs['input_ids'].squeeze(1).to(device)

            optimizer.zero_grad()
            output = model(input_ids, mask)
            loss = criterion(output, labels)
            loss.backward()
            optimizer.step()

            total_loss += loss.item()
            total_acc += (output.argmax(dim=1) == labels).sum().item()

        avg_train_loss = total_loss / len(train_data)
        avg_train_acc = total_acc / len(train_data)

        val_loss, val_acc = evaluate(model, val_loader, criterion, device)

        print(f'''Epoch {epoch+1} |
        Train Loss: {avg_train_loss:.3f}, Train Acc: {avg_train_acc:.3f} |
        Val Loss: {val_loss:.3f}, Val Acc: {val_acc:.3f}''')

    torch.save(model.state_dict(), 'bert_classifier.pt')

def evaluate(model, dataloader, criterion, device):
    model.eval()
    total_loss, total_acc = 0, 0

    with torch.no_grad():
        for batch in dataloader:
            inputs, labels = batch
            labels = labels.to(device)
            mask = inputs['attention_mask'].to(device)
            input_ids = inputs['input_ids'].squeeze(1).to(device)

            output = model(input_ids, mask)
            loss = criterion(output, labels)

            total_loss += loss.item()
            total_acc += (output.argmax(dim=1) == labels).sum().item()

    return total_loss / len(dataloader.dataset), total_acc / len(dataloader.dataset)

def test(model, test_data, label_names=None, batch_size=4):
    test_loader = DataLoader(test_data, batch_size=batch_size)
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)
    model.eval()

    all_preds = []
    all_labels = []

    with torch.no_grad():
        for batch in test_loader:
            inputs, labels = batch
            labels = labels.to(device)
            mask = inputs['attention_mask'].to(device)
            input_ids = inputs['input_ids'].squeeze(1).to(device)

            output = model(input_ids, mask)
            preds = output.argmax(dim=1)

            all_preds.extend(preds.cpu().numpy())
            all_labels.extend(labels.cpu().numpy())

    print("Test Classification Report:")
    print(classification_report(all_labels, all_preds, target_names=label_names))
                    </code>
                </div>
            </div>
            <!-- Fraud Detection Monitor éƒ¨åˆ† -->
            <div class="mb-6">
                <h2 class="text-xl font-semibold text-[var(--text-color)] mb-2">ä½¿ç”¨Fraud Detection Monitor</h2>
                <p class="text-sm text-[var(--text-color)] opacity-80 mb-4">
                    <strong>åŠŸèƒ½</strong>ï¼šå®ç°å®æ—¶è¯ˆéª—æ£€æµ‹ï¼Œç»“åˆ BERT æ¨¡å‹å’Œ Whisper è½¬å½•ç»“æœï¼Œç›‘æ§è¿ç»­æ¶ˆæ¯ä¸­çš„è¯ˆéª—æ¨¡å¼ã€‚<br>
                    <strong>ç”¨æ³•</strong>ï¼š<br>
                    - `FraudDetectionMonitor`ï¼šåŠ è½½è®­ç»ƒå¥½çš„ BERT æ¨¡å‹ï¼Œç›‘æ§æ¶ˆæ¯æµï¼Œæ£€æµ‹è¯ˆéª—æ¨¡å¼ã€‚<br>
                    - `detect_fraud`ï¼šå¯¹å•æ¡æ–‡æœ¬è¿›è¡Œè¯ˆéª—æ£€æµ‹ã€‚<br>
                    - `main`ï¼šæ”¯æŒæ‰¹é‡éŸ³é¢‘å¤„ç†æˆ–å®æ—¶æ–‡æœ¬æ£€æµ‹ã€‚<br>
                <div class="code-block" id="monitor-code">
                    <button class="copy-btn" onclick="copyCode('monitor-code')">å¤åˆ¶</button>
                    <code>
import torch
import torch.nn as nn
from transformers import BertModel, BertTokenizer
from collections import deque

class FraudDetectionMonitor:
    def __init__(self, model_path=r'D:\anti-fraud\Bert\bert_classifier.pt', bert_path="D:\\anti-fraud\\bert-base-chinese",
                 window_size=5, high_confidence_threshold=0.8, required_high_confidence=3):
        """
        Initialize the fraud detection monitor
        Args:
            model_path: Path to the saved model state dict
            bert_path: Path to BERT model files
            window_size: Number of recent messages to consider
            high_confidence_threshold: Threshold for high confidence fraud detection
            required_high_confidence: Minimum number of high confidence fraud detections needed
        """
        # Load tokenizer and model
        self.tokenizer = BertTokenizer.from_pretrained(bert_path)
        self.model = BertClassifier(num_labels=2, model_path=bert_path)
        self.model.load_state_dict(torch.load(model_path))
        self.model.eval()

        # Set device
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model.to(self.device)

        # Settings
        self.window_size = window_size
        self.high_confidence_threshold = high_confidence_threshold
        self.required_high_confidence = required_high_confidence

        # History tracking
        self.recent_messages = deque(maxlen=window_size)
        self.recent_predictions = deque(maxlen=window_size)
        self.recent_confidences = deque(maxlen=window_size)

    def predict(self, text):
        """Predict if a given text is fraudulent"""
        # Tokenize input
        inputs = self.tokenizer(text, padding=True, truncation=True, max_length=128, return_tensors="pt")
        mask = inputs['attention_mask'].to(self.device)
        input_ids = inputs['input_ids'].to(self.device)

        # Get prediction
        with torch.no_grad():
            output = self.model(input_ids, mask)
            probabilities = torch.softmax(output, dim=1)
            prediction = torch.argmax(probabilities, dim=1).item()
            confidence = probabilities[0][prediction].item()

        return prediction, confidence

    def process_message(self, text):
        """
        Process a new message and determine if it's part of a fraud pattern
        Returns:
            tuple: (is_fraud, confidence, fraud_alert)
        """
        # Get prediction
        prediction, confidence = self.predict(text)

        # Update history
        self.recent_messages.append(text)
        self.recent_predictions.append(prediction)
        self.recent_confidences.append(confidence)

        # Check for fraud pattern
        fraud_alert = self._check_fraud_pattern()

        return prediction, confidence, fraud_alert

    def _check_fraud_pattern(self):
        """Check if recent messages match a suspicious fraud pattern"""
        # Need at least window_size messages
        if len(self.recent_predictions) < self.window_size:
            return False

        # Count fraudulent messages
        fraud_count = sum(1 for p in self.recent_predictions if p == 1)

        # Count high confidence fraud detections
        high_confidence_count = sum(1 for p, c in zip(self.recent_predictions, self.recent_confidences)
                                    if p == 1 and c > self.high_confidence_threshold)

        # Check if pattern matches criteria
        if fraud_count >= self.window_size and high_confidence_count >= self.required_high_confidence:
            return True
        return False

def detect_fraud(text, monitor):
    """
    Detect fraud risk in text
    Args:
        text: Input text to analyze
        monitor: FraudDetectionMonitor instance
    Returns:
        tuple: (prediction, confidence, fraud_alert)
    """
    if not text:
        return None, None, None
    return monitor.process_message(text)

def main(audio_files=None):
    """
    Main function to process audio files and detect fraud
    Args:
        audio_files: List of audio file paths, or None for interactive mode
    """
    # Initialize FraudDetectionMonitor
    try:
        monitor = FraudDetectionMonitor(
            model_path=r'D:\anti-fraud\Bert\bert_classifier.pt',
            bert_path="D:\\anti-fraud\\bert-base-chinese",
            window_size=3,
            high_confidence_threshold=0.7,
            required_high_confidence=3
        )
    except Exception as e:
        print(f"Error initializing FraudDetectionMonitor: {e}")
        return

    # Process audio files if provided
    if audio_files:
        print("===== éŸ³é¢‘è½¬å½•ä¸è¯ˆéª—æ£€æµ‹å¼€å§‹ =====")
        for audio_path in audio_files:
            print(f"\nå¤„ç†éŸ³é¢‘: {audio_path}")
            # Transcribe audio
            text = transcribe_audio(audio_path, model_name="base")
            if text:
                print(f"è½¬å½•æ–‡æœ¬: {text}")
                # Detect fraud
                prediction, confidence, fraud_alert = detect_fraud(text, monitor)
                result = "è¯ˆéª—" if prediction == 1 else "æ­£å¸¸"
                print(f"é¢„æµ‹: {result} (ç½®ä¿¡åº¦: {confidence:.4f})")
                if fraud_alert:
                    print("\n è­¦å‘Š: å½“å‰é€šè¯æ£€æµ‹åˆ°è¯ˆéª—!")
                    print(" è¯·æé«˜è­¦æƒ•ï¼Œä¸è¦æ³„éœ²ä¸ªäººä¿¡æ¯ï¼Œä¸è¦ç‚¹å‡»å¯ç–‘é“¾æ¥ï¼Œæ¶‰åŠé’±è´¢ä¸€å¾‹ä¸ä¿¡!\n")
            else:
                print("è½¬å½•å¤±è´¥ï¼Œè·³è¿‡è¯ˆéª—æ£€æµ‹")
            print("-" * 50)

    # Interactive mode
    print("\n===== å®æ—¶æ–‡æœ¬æ£€æµ‹æ¨¡å¼ =====")
    print("è¾“å…¥ä»»æ„æ–‡æœ¬è¿›è¡Œè¯ˆéª—æ£€æµ‹ (è¾“å…¥'é€€å‡º'ç»“æŸ)")
    while True:
        user_input = input("\nè¯·è¾“å…¥æ–‡æœ¬: ")
        if user_input.lower() in ["é€€å‡º", "exit", "quit"]:
            break
        prediction, confidence, fraud_alert = detect_fraud(user_input, monitor)
        result = "è¯ˆéª—" if prediction == 1 else "æ­£å¸¸"
        print(f"é¢„æµ‹: {result} (ç½®ä¿¡åº¦: {confidence:.4f})")
        if fraud_alert:
            print("\n è­¦å‘Š: å½“å‰é€šè¯æ£€æµ‹åˆ°è¯ˆéª—!")
            print(" è¯·æé«˜è­¦æƒ•ï¼Œä¸è¦æ³„éœ²ä¸ªäººä¿¡æ¯ï¼Œä¸è¦ç‚¹å‡»å¯ç–‘é“¾æ¥ï¼Œæ¶‰åŠé’±è´¢ä¸€å¾‹ä¸ä¿¡!\n")

if __name__ == "__main__":
    # ç¤ºä¾‹éŸ³é¢‘æ–‡ä»¶åˆ—è¡¨
    audio_files = [
        r"D:\anti-fraud\whisper\testa.m4a",
        r"D:\anti-fraud\whisper\testb.m4a",
        r"D:\anti-fraud\whisper\testc.m4a",
        r"D:\anti-fraud\whisper\testd.m4a",
        r"D:\anti-fraud\whisper\teste.m4a"
    ]
    main(audio_files)
                    </code>
                </div>
            </div>
        </div>
    </div>

    <script>
        const menuButton = document.getElementById('menuButton');
        const dropdownMenu = document.getElementById('dropdownMenu');

        menuButton.addEventListener('click', () => {
            dropdownMenu.classList.toggle('show');
        });

        document.addEventListener('click', (event) => {
            if (!menuButton.contains(event.target) && !dropdownMenu.contains(event.target)) {
                dropdownMenu.classList.remove('show');
            }
        });

        function copyCode(elementId) {
            const codeElement = document.getElementById(elementId).querySelector('code');
            const text = codeElement.textContent;
            navigator.clipboard.writeText(text).then(() => {
                alert('ä»£ç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
            }).catch(err => {
                console.error('å¤åˆ¶å¤±è´¥:', err);
            });
        }
    </script>
</body>
</html>